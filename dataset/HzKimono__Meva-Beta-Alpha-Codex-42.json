{
  "instance_id": "HzKimono__Meva-Beta-Alpha-Codex-42",
  "repo": "HzKimono/Meva-Beta-Alpha-Codex",
  "base_commit": "5afb59fedc4246ba676105193a16ca06bbc07b4d",
  "version": "unknown",
  "created_at": "2026-02-13T23:21:26.856365+00:00",
  "problem_statement": "## Problem Statement\n\nThe `ExchangeRulesService.get_rules()` method incorrectly reports the status of cached symbol rules. When a cache hit occurs, the method always returns `\"ok\"` as the status, even if the cached entry was a fallback result from a previous failed exchange info lookup.\n\nThis occurs because the cache validity check only verifies expiration and doesn't preserve the original status (`\"ok\"` vs `\"fallback\"`). As a result, callers cannot distinguish between cached successful results and cached fallback results, which may lead to incorrect handling of trading rules that were obtained from fallback logic rather than the exchange API.",
  "patch": "diff --git a/src/btcbot/services/exchange_rules_service.py b/src/btcbot/services/exchange_rules_service.py\nindex 4249e5f..5a8bc89 100644\n--- a/src/btcbot/services/exchange_rules_service.py\n+++ b/src/btcbot/services/exchange_rules_service.py\n@@ -51,7 +51,8 @@ class SymbolRules:\n @dataclass\n class _CachedRules:\n     rules: SymbolRules\n-    expires_at: datetime\n+    status: str\n+    cached_at: datetime\n \n \n class ExchangeRulesService:\n@@ -95,8 +96,8 @@ class ExchangeRulesService:\n         key = _norm_symbol(symbol)\n         now = datetime.now(UTC)\n         cached = self._cache.get(key)\n-        if cached and cached.expires_at > now:\n-            return cached.rules, \"ok\"\n+        if cached and (now - cached.cached_at) < timedelta(seconds=self.cache_ttl_sec):\n+            return cached.rules, cached.status\n \n         index: dict[str, object] = {}\n         get_info = getattr(self.exchange, \"get_exchange_info\", None)\n@@ -114,7 +115,8 @@ class ExchangeRulesService:\n             fallback = self._fallback_rules()\n             self._cache[key] = _CachedRules(\n                 rules=fallback,\n-                expires_at=now + timedelta(seconds=self.cache_ttl_sec),\n+                status=\"fallback\",\n+                cached_at=now,\n             )\n             return fallback, \"fallback\"\n \n@@ -144,13 +146,15 @@ class ExchangeRulesService:\n             fallback = self._fallback_rules()\n             self._cache[key] = _CachedRules(\n                 rules=fallback,\n-                expires_at=now + timedelta(seconds=self.cache_ttl_sec),\n+                status=\"fallback\",\n+                cached_at=now,\n             )\n             return fallback, \"fallback\"\n \n         cached_rules = _CachedRules(\n             rules=converted,\n-            expires_at=now + timedelta(seconds=self.cache_ttl_sec),\n+            status=\"ok\",\n+            cached_at=now,\n         )\n         for alias in _pair_symbol_candidates(match):\n             self._cache[_norm_symbol(alias)] = cached_rules\ndiff --git a/src/btcbot/services/stage7_cycle_runner.py b/src/btcbot/services/stage7_cycle_runner.py\nindex 874c3fe..40936ae 100644\n--- a/src/btcbot/services/stage7_cycle_runner.py\n+++ b/src/btcbot/services/stage7_cycle_runner.py\n@@ -86,28 +86,28 @@ class Stage7CycleRunner:\n                     )\n                 ]\n \n-            rules_symbols_fallback: list[str] = []\n-            rules_symbols_invalid: list[str] = []\n-            rules_symbols_missing: list[str] = []\n+            rules_symbols_fallback: set[str] = set()\n+            rules_symbols_invalid: set[str] = set()\n+            rules_symbols_missing: set[str] = set()\n             rules_unavailable: dict[str, str] = {}\n-            for symbol in sorted({normalize_symbol(s) for s in universe_result.selected_symbols}):\n+            for symbol in symbols_needed:\n                 _, status = rules_service.get_symbol_rules_status(symbol)\n                 if status == \"fallback\":\n-                    rules_symbols_fallback.append(symbol)\n+                    rules_symbols_fallback.add(symbol)\n                 elif status == \"invalid\":\n-                    rules_symbols_invalid.append(symbol)\n+                    rules_symbols_invalid.add(symbol)\n                     rules_unavailable[symbol] = status\n                 elif status == \"missing\":\n-                    rules_symbols_missing.append(symbol)\n+                    rules_symbols_missing.add(symbol)\n                     rules_unavailable[symbol] = status\n \n             rules_stats = {\n                 \"rules_fallback_used_count\": len(rules_symbols_fallback),\n                 \"rules_invalid_count\": len(rules_symbols_invalid),\n                 \"rules_missing_count\": len(rules_symbols_missing),\n-                \"rules_symbols_fallback\": rules_symbols_fallback,\n-                \"rules_symbols_invalid\": rules_symbols_invalid,\n-                \"rules_symbols_missing\": rules_symbols_missing,\n+                \"rules_symbols_fallback\": sorted(rules_symbols_fallback),\n+                \"rules_symbols_invalid\": sorted(rules_symbols_invalid),\n+                \"rules_symbols_missing\": sorted(rules_symbols_missing),\n             }\n \n             base_mode = state_store.get_latest_risk_mode()\n@@ -164,6 +164,19 @@ class Stage7CycleRunner:\n                             }\n                         )\n                         continue\n+                    if normalized_symbol in rules_unavailable:\n+                        skipped_actions.append(\n+                            {\n+                                \"symbol\": normalized_symbol,\n+                                \"side\": action.side,\n+                                \"qty\": str(action.qty),\n+                                \"status\": \"skipped\",\n+                                \"reason\": (\n+                                    f\"rules_unavailable:{rules_unavailable[normalized_symbol]}\"\n+                                ),\n+                            }\n+                        )\n+                        continue\n                     if normalized_symbol not in mark_prices:\n                         skipped_actions.append(\n                             {\n@@ -226,7 +239,7 @@ class Stage7CycleRunner:\n                     for item in universe_result.scored[: max(0, settings.stage7_universe_size)]\n                 ],\n                 intents_summary={\n-                    \"lifecycle_actions_total\": len(actions),\n+                    \"order_decisions_total\": len(actions),\n                     \"orders_simulated\": simulated_count,\n                     \"order_intents_total\": len(order_intents),\n                     \"order_intents_planned\": planned_count,\n",
  "test_patch": "diff --git a/tests/test_exchange_rules_service.py b/tests/test_exchange_rules_service.py\nindex 71ab408..1dfe435 100644\n--- a/tests/test_exchange_rules_service.py\n+++ b/tests/test_exchange_rules_service.py\n@@ -112,6 +112,25 @@ def test_invalid_metadata_not_cached_as_zero() -> None:\n     assert second_status == \"invalid\"\n \n \n+def test_fallback_cache_preserves_status_when_metadata_not_required() -> None:\n+    settings = Settings(\n+        DRY_RUN=True,\n+        STAGE7_ENABLED=True,\n+        STAGE7_RULES_REQUIRE_METADATA=False,\n+    )\n+    exchange = FakeExchangeClient()\n+    service = ExchangeRulesService(exchange, settings=settings)\n+\n+    first_rules, first_status = service.get_symbol_rules_status(\"ETH_TRY\")\n+    second_rules, second_status = service.get_symbol_rules_status(\"ETH_TRY\")\n+\n+    assert first_rules is not None\n+    assert second_rules is not None\n+    assert first_status == \"fallback\"\n+    assert second_status == \"fallback\"\n+    assert exchange.exchange_info_calls == 1\n+\n+\n def test_validate_notional_price_non_positive() -> None:\n     service = ExchangeRulesService(FakeExchangeClient())\n \ndiff --git a/tests/test_stage7_run_integration.py b/tests/test_stage7_run_integration.py\nindex 2177234..d189cd1 100644\n--- a/tests/test_stage7_run_integration.py\n+++ b/tests/test_stage7_run_integration.py\n@@ -41,6 +41,9 @@ def test_stage7_run_dry_run_persists_trace_and_metrics(monkeypatch, tmp_path) ->\n     class _Pair:\n         def __init__(self, pair_symbol: str) -> None:\n             self.pair_symbol = pair_symbol\n+            self.tick_size = Decimal(\"0.1\")\n+            self.step_size = Decimal(\"0.0001\")\n+            self.min_total_amount = Decimal(\"10\")\n \n     class _Exchange:\n         def get_exchange_info(self):\n@@ -223,6 +226,7 @@ def test_stage7_run_respects_reduce_risk_mode(monkeypatch, tmp_path) -> None:\n         STAGE7_ENABLED=True,\n         STATE_DB_PATH=str(db_path),\n         SYMBOLS=\"BTC_TRY\",\n+        STAGE7_RULES_REQUIRE_METADATA=False,\n     )\n \n     assert cli.run_cycle_stage7(settings, force_dry_run=True) == 0\n@@ -320,6 +324,7 @@ def test_stage7_run_skips_open_order_with_missing_mark_price(monkeypatch, tmp_pa\n         STAGE7_ENABLED=True,\n         STATE_DB_PATH=str(db_path),\n         SYMBOLS=\"BTC_TRY\",\n+        STAGE7_RULES_REQUIRE_METADATA=False,\n     )\n \n     assert cli.run_cycle_stage7(settings, force_dry_run=True) == 0\n@@ -389,9 +394,13 @@ def test_stage7_policy_skip_symbol(monkeypatch, tmp_path) -> None:\n         del self, settings\n         return 0\n \n+    class _Pair:\n+        def __init__(self, pair_symbol: str) -> None:\n+            self.pair_symbol = pair_symbol\n+\n     class _Exchange:\n         def get_exchange_info(self):\n-            return []\n+            return [_Pair(\"BTC_TRY\")]\n \n         def get_ticker_stats(self):\n             return [\n@@ -405,8 +414,11 @@ def test_stage7_policy_skip_symbol(monkeypatch, tmp_path) -> None:\n             ]\n \n         def get_orderbook(self, symbol):\n-            del symbol\n-            return Decimal(\"99\"), Decimal(\"100\")\n+            if symbol == \"BTCTRY\":\n+                return Decimal(\"99\"), Decimal(\"100\")\n+            if symbol == \"XRPTRY\":\n+                return Decimal(\"19\"), Decimal(\"20\")\n+            raise RuntimeError(\"unknown symbol\")\n \n         def get_candles(self, symbol, lookback):\n             del symbol\n@@ -427,6 +439,21 @@ def test_stage7_policy_skip_symbol(monkeypatch, tmp_path) -> None:\n         _selected_btc_universe,\n     )\n \n+    monkeypatch.setattr(\n+        \"btcbot.services.state_store.StateStore.list_stage4_open_orders\",\n+        lambda self: [\n+            SimpleNamespace(\n+                status=\"simulated_submitted\",\n+                symbol=\"XRP_TRY\",\n+                side=\"SELL\",\n+                price=Decimal(\"20\"),\n+                qty=Decimal(\"1\"),\n+                client_order_id=\"xrp1\",\n+                exchange_order_id=\"xrp-ex-1\",\n+            )\n+        ],\n+    )\n+\n     settings = Settings(\n         DRY_RUN=True,\n         STAGE7_ENABLED=True,\n@@ -452,6 +479,20 @@ def test_stage7_policy_skip_symbol(monkeypatch, tmp_path) -> None:\n     summary = json.loads(str(cycle[\"intents_summary_json\"]))\n     assert summary[\"rules_stats\"][\"rules_missing_count\"] >= 1\n \n+    conn = sqlite3.connect(str(db_path))\n+    conn.row_factory = sqlite3.Row\n+    try:\n+        cycle_full = conn.execute(\"SELECT order_decisions_json FROM stage7_cycle_trace\").fetchone()\n+    finally:\n+        conn.close()\n+    decisions = json.loads(str(cycle_full[\"order_decisions_json\"]))\n+    assert any(\n+        decision.get(\"symbol\") == \"XRPTRY\"\n+        and decision.get(\"status\") == \"skipped\"\n+        and str(decision.get(\"reason\", \"\")).startswith(\"rules_unavailable:\")\n+        for decision in decisions\n+    )\n+\n \n def test_stage7_policy_observe_only_cycle(monkeypatch, tmp_path) -> None:\n     db_path = tmp_path / \"stage7_observe_cycle.db\"\n@@ -460,9 +501,13 @@ def test_stage7_policy_observe_only_cycle(monkeypatch, tmp_path) -> None:\n         del self, settings\n         return 0\n \n+    class _Pair:\n+        def __init__(self, pair_symbol: str) -> None:\n+            self.pair_symbol = pair_symbol\n+\n     class _Exchange:\n         def get_exchange_info(self):\n-            return []\n+            return [_Pair(\"BTC_TRY\")]\n \n         def get_ticker_stats(self):\n             return [\n@@ -476,8 +521,11 @@ def test_stage7_policy_observe_only_cycle(monkeypatch, tmp_path) -> None:\n             ]\n \n         def get_orderbook(self, symbol):\n-            del symbol\n-            return Decimal(\"99\"), Decimal(\"100\")\n+            if symbol == \"BTCTRY\":\n+                return Decimal(\"99\"), Decimal(\"100\")\n+            if symbol == \"XRPTRY\":\n+                return Decimal(\"19\"), Decimal(\"20\")\n+            raise RuntimeError(\"unknown symbol\")\n \n         def get_candles(self, symbol, lookback):\n             del symbol\n@@ -497,6 +545,20 @@ def test_stage7_policy_observe_only_cycle(monkeypatch, tmp_path) -> None:\n         \"btcbot.services.stage7_cycle_runner.UniverseSelectionService.select_universe\",\n         _selected_btc_universe,\n     )\n+    monkeypatch.setattr(\n+        \"btcbot.services.state_store.StateStore.list_stage4_open_orders\",\n+        lambda self: [\n+            SimpleNamespace(\n+                status=\"simulated_submitted\",\n+                symbol=\"XRP_TRY\",\n+                side=\"SELL\",\n+                price=Decimal(\"20\"),\n+                qty=Decimal(\"1\"),\n+                client_order_id=\"xrp2\",\n+                exchange_order_id=\"xrp-ex-2\",\n+            )\n+        ],\n+    )\n \n     settings = Settings(\n         DRY_RUN=True,\n",
  "hints_text": "",
  "environment_setup_commit": "5afb59fedc4246ba676105193a16ca06bbc07b4d",
  "install_config": {
    "python": "3.12",
    "packages": null,
    "install": "pip install -e \".[dev]\"",
    "test_cmd": "python -m pytest -q",
    "pre_install": [],
    "reqs_path": [],
    "env_yml_path": [],
    "pip_packages": []
  },
  "meta": {
    "commit_name": "head_commit",
    "num_modified_files": 2,
    "has_test_patch": true,
    "is_lite": true,
    "llm_score": {
      "difficulty_score": null,
      "issue_text_score": null,
      "test_score": null
    },
    "solution_lines": 51,
    "lines_added": 34,
    "lines_removed": 17,
    "repo_stars": 0,
    "repo_forks": 0,
    "repo_contributors": 1,
    "has_ci": true,
    "has_test_framework": true,
    "is_archived": false,
    "is_fork": false
  },
  "license_name": null,
  "FAIL_TO_PASS": [],
  "PASS_TO_PASS": [],
  "requirements": "",
  "environment": ""
}